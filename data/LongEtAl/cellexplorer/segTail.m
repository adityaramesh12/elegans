function [segImg2, rgnSeg] = segTail(inimg, rgnMinSize, rgnConvexity, GFPsegImg, RFPsegImg,rgnMaxSize, useGFPRFPtag, sesize) % function [segImg2, rgnSeg] = segTail(inimg,rgnMinSize, rgnConvexity, GFPsegImg, RFPsegImg,rgnMaxSize, useGFPRFPtag, sesize)% %  segment tail image inimg using watershed segmentation %% Copyright F. Long% Aug 14, 2008imgproptag = 0;% ------------------------------------------------------------% thresholding to get the foreground mask% ------------------------------------------------------------fprintf('Thresholding to get the foreground mask...\n');threInitial = (graythresh(inimg)*255);maskImg = inimg>threInitial;maskImg = uint8(gaussf(maskImg,1)); t1 = graythresh(uint8(inimg(maskImg>0)))*255; % foreground of foregroundhval = max(inimg(:))-(threInitial+t1)/2;threImg = imreconstruct(inimg-hval,inimg); e = uint8(gaussf((inimg-threImg)>0,1));e = uint16(bwlabeln(e.*uint8(maskImg>0)));segImgInit = e;% ----------------------------------------------------% remove regions already been segmented by GFP/RFP channel% ----------------------------------------------------fprintf('remove regions already segmented by GFP/RFP ...\n');se = strel('disk', sesize);if ~isempty(GFPsegImg) % remove regions already been segmented by GFP channel    GFPsegImgDilate = imdilate(GFPsegImg,se);        bb = e .* uint16(GFPsegImgDilate==0);    e = imdilate(imerode(bb,se),se);    dip_image(e);end;if ~isempty(RFPsegImg) % remove regions already been segmented by RFP channel    RFPsegImgDilate = imdilate(RFPsegImg,se);        bb = e .* uint16(RFPsegImgDilate==0);    e = imdilate(imerode(bb,se),se);    dip_image(e);end;if isempty(RFPsegImg) & isempty(GFPsegImg)    useGFPRFPtag = 0;end;inimg2 = inimg;if useGFPRFPtag == 1 % use GFP/RFP mask directly        if ~isempty(GFPsegImg)         inimg2 = inimg2 .* uint8(GFPsegImgDilate ==0);    end;    if ~isempty(RFPsegImg)         inimg2 = inimg2 .* uint8(RFPsegImgDilate ==0);            end;end;maskImg = e>0; % ---------------------------------------------------------------------% fill holes for regions that are likely to be single nucleus, for those% that contain many nuclei, do not fill holes, since it may also fill the% space between nuclei% ---------------------------------------------------------------------fprintf('fill holes ...\n');stat = regionprops(e,'Area','PixelIdxList');rgn = [stat.Area];idx2 = find((rgn>rgnMinSize)&(rgn<rgnMaxSize));kknum = length(idx2);tt = e;for kk=1:kknum    tt(:) = 0;    tt(stat(idx2(kk)).PixelIdxList) = 1;    [argn, xxmin, yymin, zzmin] = extractCube_FL2(tt, stat(idx2(kk)).PixelIdxList);        argn = fillholes(argn);     tt([yymin: yymin+size(argn,1)-1], [xxmin: xxmin+size(argn,2)-1], [zzmin: zzmin+size(argn,3)-1]) = argn;    e(tt>0) = idx2(kk);    end;         % -----------------------% watershed segmentation % -----------------------fprintf('Segmenting the remaining regions ...\n');stat = regionprops(e,'Area');rgn = [stat.Area];idx2 = find(rgn>rgnMinSize);[segImg,threImg] = watershedSeg3d62(e, inimg2, idx2, rgnMinSize, rgnConvexity, threImg, imgproptag,5, rgnMaxSize); dip_image(segImg);% -----------------------% % regionn dilate % -----------------------threConvexity = 1.0;segImg2 = rgndilate62(segImg, inimg2,maskImg,threConvexity, threInitial,'morp'); % --------------------% recover missed cells% --------------------fprintf('Recovering missing regions ...\n');[segImg2, foundflg] = rgnRecover80(inimg2, segImg);minsz = 0;[rgnSeg,segImg2] = rgnStat3(inimg2, uint16(segImg2), minsz,1,0); % -----------------------------% further split big regions% -----------------------------fprintf('Further splitting and merging ...\n');szratio = 1.5; [segImg2, foundflg] = rgnSplit(inimg, segImg2, rgnSeg, szratio);if (foundflg ==1)    minsz = 0;    [rgnSeg,segImg2] = rgnStat3(inimg2, uint16(segImg2), minsz,1,0);  end;% ----------------------------------------% deal with small regions (not quite necessary)% ----------------------------------------szratio = 0.5;[segImg2, foundflg] = rgnMerge80(inimg2, segImg2, rgnSeg, szratio);if (foundflg ==1)    minsz = 0;    [rgnSeg,segImg2] = rgnStat3(inimg2, uint16(segImg2), minsz,1,0); end;    %---------------------------------------% add segmentation result in GFP channel%---------------------------------------fprintf('Add back GFP/RFP nuclei ...\n');if ~isempty(GFPsegImg)    combineImg = GFPsegImgDilate;    if ~isempty(RFPsegImg)        combineImg(RFPsegImgDilate>0) = max(combineImg(:)) + RFPsegImgDilate(RFPsegImgDilate>0);        overlapImg = uint8(GFPsegImgDilate>0) .* uint8(RFPsegImgDilate>0);        pixlist = find(overlapImg>0);        GFPnucleiIdx = unique(GFPsegImgDilate(pixlist));        ssGFP = regionprops(GFPsegImgDilate, 'Area', 'PixelIdxList');        ssRFP = regionprops(RFPsegImgDilate, 'Area', 'PixelIdxList');                for i=1:length(GFPnucleiIdx)            i            GFParea = ssGFP(GFPnucleiIdx(i)).Area;            RFPidx = unique(RFPsegImgDilate(ssGFP(GFPnucleiIdx(i)).PixelIdxList));            RFPidx = setdiff(RFPidx,0);            for j=1:length(RFPidx)                RFParea = ssRFP(RFPidx(j)).Area;                commenarea = length(intersect(ssRFP(RFPidx(j)).PixelIdxList, ssGFP(GFPnucleiIdx(i)).PixelIdxList));                ra1 = commenarea/GFParea;                ra2 = commenarea/RFParea;                                if (ra1>0.5)|(ra2>0.5)                     combineImg(ssRFP(RFPidx(j)).PixelIdxList) = GFPnucleiIdx(i);                end;            end;        end;    end;        segImg2 = segImg2 + (max(segImg2(:)) + combineImg) .* uint16(combineImg>0); % GFPsegImg has been dilatedend;        % make label continuousminsz = 0;[rgnSeg,segImg2] = rgnStat3(inimg2, uint16(segImg2), minsz,0,0); % make labels continous, do not compute convexity and elongation% test the uniqueness of the labelsnum = max(segImg2(:));tt=segImg2;ss = regionprops(segImg2,'PixelIdxList');rgnMultipleLabels = [];for i=1:num    tt(:)= 0;    tt(ss(i).PixelIdxList) = 1;    tt = bwlabeln(tt);    if max(tt(:))>1        rgnMultipleLabels = [rgnMultipleLabels,i];    end;    end;%rgnMultipleLabelsreturn;