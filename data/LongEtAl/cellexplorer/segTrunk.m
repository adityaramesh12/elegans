 function [segImg2, rgnSeg, sesize] = segTrunk(inimg, rgnMinSize, rgnConvexity, GFPsegImg, RFPsegImg,rgnMaxSize,useGFPRFPtag) %  function [segImg2, rgnSeg, sesize] = segTrunk(inimg, rgnMinSize, rgnConvexity, GFPsegImg, RFPsegImg,rgnMaxSize,useGFPRFPtag) %% segment nuclei in trunk, called by segNucleiDAPI.m%% Copyright Fuhui Long% Aug 12~Aug 14, 2008imgproptag = 1;%-----------% fill holes%-----------threlowest = 10;fprintf('filling holes ...\n');inimg2 = fillNucleiHolesInStack(inimg, threlowest,rgnMinSize);               %------------------------------------------% thresholding, get a good mask for segmentation%------------------------------------------fprintf('Thresholding ...\n');gg = inimg2-inimg;threholes = min(inimg2(find(gg>0)));threInitial = min(graythresh(inimg2)*255, threholes);bb = uint8(gaussf((inimg2>threInitial),1));e = uint16(bwlabeln(bb));threImg = uint8(e);threImg(:) = threInitial;stat = regionprops(e,'Area','PixelIdxList');rgn = [stat.Area];idx2 = find(rgn>rgnMinSize);kknum = length(idx2);tt = e;for kk=1:kknum    tt(:) = 0;    tt(stat(idx2(kk)).PixelIdxList) = 1;    [argn, xxmin, yymin, zzmin] = extractCube_FL2(tt, stat(idx2(kk)).PixelIdxList);        argn = fillholes(argn);     tt([yymin: yymin+size(argn,1)-1], [xxmin: xxmin+size(argn,2)-1], [zzmin: zzmin+size(argn,3)-1]) = argn;    e(tt>0) = idx2(kk);    end;         segImgInit = e; % ----------------------------------------------------% remove regions already been segmented by GFP channel% ----------------------------------------------------fprintf('remove regions already segmented by GFP/RFP ...\n');sesize = 1;if ~isempty(GFPsegImg) % remove regions already been segmented by GFP channel	ss1 = regionprops(GFPsegImg, 'Area', 'Centroid');	idxx = find([ss1.Area]>0);	idxxnum = length(idxx);	ss2 = regionprops(e, 'Area', 'Centroid');	for i=1:idxxnum		labelval = e(round(ss1(idxx(i)).Centroid(2)),round(ss1(idxx(i)).Centroid(1)),round(ss1(idxx(i)).Centroid(3)));        if (labelval>0)             rr(i) = ss1(idxx(i)).Area/ss2(labelval).Area;        end;	end;	if max(rr)<0.85		sesize = 2;	else		sesize = 1;	end;	se = strel('disk',sesize);    GFPsegImgDilate = imdilate(GFPsegImg,se);        bb = uint16(e) .* uint16(GFPsegImgDilate==0);    e = imdilate(imerode(bb,se),se);    e = bwlabeln(e); end;if ~isempty(RFPsegImg) % remove regions already been segmented by RFP channel	ss1 = regionprops(RFPsegImg, 'Area', 'Centroid');	idxx = find([ss1.Area]>0);	idxxnum = length(idxx);	ss2 = regionprops(e, 'Area', 'Centroid');	for i=1:idxxnum		labelval = e(round(ss1(idxx(i)).Centroid(2)),round(ss1(idxx(i)).Centroid(1)),round(ss1(idxx(i)).Centroid(3)));        if (labelval>0)             rr(i) = ss1(idxx(i)).Area/ss2(labelval).Area;        end;	end;	if max(rr)<0.85		sesize = 2;	else		sesize = 1;	end;	se = strel('disk',sesize);    RFPsegImgDilate = imdilate(RFPsegImg,se);        bb = uint16(e) .* uint16(RFPsegImgDilate==0);    e = imdilate(imerode(bb,se),se);    e = bwlabeln(e); end;maskImg = e>0; if useGFPRFPtag == 1          if ~isempty(GFPsegImg) % remove regions already been segmented by GFP channel        inimg2 = inimg2 .* uint8(GFPsegImgDilate ==0);    end;    if ~isempty(RFPsegImg) % remove regions already been segmented by GFP channel        inimg2 = inimg2 .* uint8(RFPsegImgDilate ==0);     end;  end;% --------------------------------------------------------------------% watershed segmentation to get a reasonable estimation of the median size % --------------------------------------------------------------------fprintf('Segmenting the remaining regions ...\n');[rgnSeg,e] = rgnStat3(inimg2, uint16(e),rgnMinSize,1,0); stat = regionprops(e,'PixelIdxList');idx2 = find(rgnSeg(:,2)>0.92); segImg = uint16(e);segImg(:) = 0;for i=1:length(idx2)    segImg(stat(idx2(i)).PixelIdxList) = i;end;% watershed segmentation for low convexity regionsidx2 = setdiff([1:max(e(:))], idx2);[segImgtmp,threImg] = watershedSeg3d63(e, inimg2, idx2, rgnMinSize, rgnConvexity, threImg, imgproptag,5, rgnMaxSize); segImg(segImgtmp>0) = max(segImg(:)) + segImgtmp(segImgtmp>0);% -------------------------------------------------------------------% remove small regions caused by the residue of GFP or RFP channels% -------------------------------------------------------------------fprintf('Remove residues ...\n');if (~isempty(GFPsegImg)) | (~isempty(RFPsegImg))     stat = regionprops(segImg, 'Area', 'PixelIdxList', 'Centroid');    mediansz = median([stat.Area]);    idx2 = find([stat.Area] < mediansz/3);        ss = regionprops(segImg, 'Centroid');        hh = [ss.Centroid];    iii = find(~isnan(hh));    hh = hh(iii);    hhlen = length(hh);        x1 = hh(1:3:hhlen)';    y1 = hh(2:3:hhlen)';    z1 = hh(3:3:hhlen)';            kkk = [];    if ~isempty(GFPsegImg)        ss = regionprops(GFPsegImg, 'Centroid');        hh = [ss.Centroid];        iii = find(~isnan(hh));        hh = hh(iii);        hhlen = length(hh);        x2 = hh(1:3:hhlen)';        y2 = hh(2:3:hhlen)';        z2 = hh(3:3:hhlen)';        dii = sqrt(dist2([x1(idx2),y1(idx2),z1(idx2)],[x2,y2,z2]));        [sortval, sortidx] = sort(dii,2);        mytmp = idx2(intersect(find(sortval(:,1)>15), find([stat(idx2).Area]>rgnMinSize)));% 15 pixels far enough        kkk = union(kkk, mytmp);     end;        if ~isempty(RFPsegImg)        ss = regionprops(RFPsegImg, 'Centroid');        hh = [ss.Centroid];        iii = find(~isnan(hh));        hh = hh(iii);        hhlen = length(hh);        x2 = hh(1:3:hhlen)';        y2 = hh(2:3:hhlen)';        z2 = hh(3:3:hhlen)';        dii = sqrt(dist2([x1(idx2),y1(idx2),z1(idx2)],[x2,y2,z2]));        [sortval, sortidx] = sort(dii,2);        mytmp = idx2(intersect(find(sortval(:,1)>15), find([stat(idx2).Area]>rgnMinSize)));% 15 pixels far enough        kkk = union(kkk, mytmp);     end;        idx2 = setdiff(idx2,kkk);    nidx2 = length(idx2);    % remove RFP/GFP residues    for i=1:nidx2        segImg(stat(idx2(i)).PixelIdxList) = 0;    end;end;minsz = 0;[rgnSeg,segImg2] = rgnStat3(inimg2, uint16(segImg), minsz,1,0);  % -----------------------------% further split big regions% -----------------------------fprintf('Futher split and merge ...\n');szratio = 2.5;[segImg2, foundflg] = rgnSplit(inimg2, segImg2, rgnSeg, szratio);if (foundflg == 1)    minsz = 0;    [rgnSeg,segImg2] = rgnStat3(inimg2, uint16(segImg2), minsz,1,0); end;% ----------------------------------------% deal with small regions% ----------------------------------------szratio = 0.5;[segImg2, foundflg] = rgnMerge80(inimg2, segImg2, rgnSeg, szratio);% get statistics of regionsif (foundflg ==1)    minsz = 0;    [rgnSeg,segImg2] = rgnStat3(inimg2, uint16(segImg2), minsz,1,0); end;%---------------------------------------% add segmentation result in GFP channel%---------------------------------------fprintf('Add back GFP/RFP nuclei ...\n');% combine GFP and RFP maskif ~isempty(GFPsegImg)    combineImg = GFPsegImgDilate;    if ~isempty(RFPsegImg)        combineImg(RFPsegImgDilate>0) = max(combineImg(:)) + RFPsegImgDilate(RFPsegImgDilate>0);        overlapImg = uint8(GFPsegImgDilate>0) .* uint8(RFPsegImgDilate>0);        pixlist = find(overlapImg>0);        GFPnucleiIdx = unique(GFPsegImgDilate(pixlist));        ssGFP = regionprops(GFPsegImgDilate, 'Area', 'PixelIdxList');        ssRFP = regionprops(RFPsegImgDilate, 'Area', 'PixelIdxList');                for i=1:length(GFPnucleiIdx)            i            GFParea = ssGFP(GFPnucleiIdx(i)).Area;            RFPidx = unique(RFPsegImgDilate(ssGFP(GFPnucleiIdx(i)).PixelIdxList));            RFPidx = setdiff(RFPidx,0);            for j=1:length(RFPidx)                RFParea = ssRFP(RFPidx(j)).Area;                commenarea = length(intersect(ssRFP(RFPidx(j)).PixelIdxList, ssGFP(GFPnucleiIdx(i)).PixelIdxList));                ra1 = commenarea/GFParea;                ra2 = commenarea/RFParea;                                if (ra1>0.5)|(ra2>0.5) % enough degree of overlapping                    combineImg(ssRFP(RFPidx(j)).PixelIdxList) = GFPnucleiIdx(i);                end;            end;        end;    end;        segImg2 = segImg2 + (max(segImg2(:)) + combineImg) .* uint16(combineImg>0); % GFPsegImg has been dilatedend;% make labels continousminsz = 0;[rgnSeg,segImg2] = rgnStat3(inimg2, uint16(segImg2), minsz,0,0); % make labels continous, do not compute convexity and elongation% test the uniqueness of the labelsnum = max(segImg2(:));tt=segImg2;ss = regionprops(segImg2,'PixelIdxList');rgnMultipleLabels = [];for i=1:num    tt(:)= 0;    tt(ss(i).PixelIdxList) = 1;    tt = bwlabeln(tt);    if max(tt(:))>1        rgnMultipleLabels = [rgnMultipleLabels,i];    end;    end;rgnMultipleLabelsreturn;